[
  {
    "agent": "Tech Researcher",
    "task_name": "1. Try to access the Official URL: https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "full_prompt": "\n        1. Try to access the Official URL: https://leetcode.com/problems/search-in-rotated-sorted-array/\n        2. If that fails (403/404), use 'Internet Search' to find: \"Search in Rotated Sorted Array geeksforgeeks problem\".\n        3. CRITICAL: The search results will contain 'link' fields. COPY one of those links exactly. DO NOT GUESS A URL.\n        4. CRITICAL: When searching, ignore pages like \"Complete Guide\", \"Syllabus\", \"GATE Notes\", or \"file list\".\n        5. Look for specific tutorial pages, e.g., containing \"algorithm\", \"problem\", or \"tutorial\" in the title.\n        6. Use 'Website Scraper' on that new link.\n        7. Extract:\n           - Problem Statement.\n           - At least 3 Input/Output Examples.\n           - Constraints.\n        ",
    "response": "**Problem Statement:** Find an element in a rotated sorted array using binary search.\n\n**Solution:**\n\n*   The solution uses two functions: `binarySearch` and `findPivot`.\n*   The `findPivot` function finds the index of the smallest element (pivot) in the array.\n*   If the pivot is at index 0, the entire array is sorted, so a standard binary search is applied to the whole array.\n*   Otherwise, the key is compared with the first element: if it's greater than or equal, binary search is performed on the left half; if not, on the right half.\n\n**Code:**\n\n```cpp\n#include <iostream>\n#include <vector>\n\n// An iterative binary search function\nint binarySearch(std::vector<int>& arr, int lo, int hi, int x) {\n    while (lo <= hi) {\n        int mid = lo + (hi - lo) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] < x)\n            lo = mid + 1;\n        else\n            hi = mid - 1;\n    }\n    return -1;\n}\n\n// Function to return pivot (index of the smallest element)\nint findPivot(std::vector<int>& arr, int lo, int hi) {\n    while (lo <= hi) {\n        // The current subarray is already sorted,\n        // the minimum is at the low index\n        if (arr[lo] <= arr[hi])\n            return lo;\n        int mid = (lo + hi) / 2;\n        // The right half is not sorted. So\n        // the minimum element must be in the\n        // right half.\n        if (arr[mid] > arr[hi])\n            lo = mid + 1;\n        // The right half is sorted. Note that in\n        // this case, we do not change high to mid - 1\n        // but keep it to mid. The mid element\n        // itself can be the smallest\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\n// Searches an element key in a pivoted sorted array arr of size n\nint search(std::vector<int>& arr, int key) {\n    int n = arr.size();\n    int pivot = findPivot(arr, 0, n - 1);\n    // If we found a pivot, then first compare with pivot and then search in two subarrays around pivot\n    if (arr[pivot] == key)\n        return pivot;\n    // If the minimum element is present at index 0, then the whole array is sorted\n    if (pivot == 0)\n        return binarySearch(arr, 0, n - 1, key);\n    if (arr[0] <= key)\n        return binarySearch(arr, 0, pivot - 1, key);\n    return binarySearch(arr, pivot + 1, n - 1, key);\n}\n\nint main() {\n    std::vector<int> arr = {5, 6, 7, 8, 9, 10, 1, 2, 3};\n    int key = 3;\n    std::cout << search(arr, key) << std::endl; // Output: 4\n    return 0;\n}\n```\n\n**Time Complexity:** The time complexity of the `binarySearch` function is O(log n), where n is the size of the array. However, due to the rotation of the array, the overall time complexity becomes O(n) in the worst case.\n\n**Space Complexity:** The space complexity is O(1) because we are using a constant amount of extra space for storing indices and variables."
  },
  {
    "agent": "Problem Architect",
    "task_name": "You are given raw text scraped from a coding website. It is messy and may contain multiple solutions (C++, Java, etc.).",
    "full_prompt": "\n        You are given raw text scraped from a coding website. It is messy and may contain multiple solutions (C++, Java, etc.).\n        \n        YOUR JOB:\n        1. Extract the core **Problem Statement**.\n        2. Extract or Create 3 clear **Input/Output Examples**.\n        3. Define the **Constraints** (if missing, invent reasonable ones, e.g., 1 <= N <= 10^5).\n        4. REMOVE any solution code (C++, Python implementations) found in the text. We only want the *Question*.\n        \n        RAW TEXT INPUT:\n        Analyze the raw content provided by the Tech Researcher above.\n        ",
    "response": "```\nTitle: Find an element in a rotated sorted array using binary search.\nDescription: Analyze the raw content provided by the Tech Researcher above.\nExamples:\n1. Input: arr = [5, 6, 7, 8, 9, 10, 1, 2, 3], key = 3\n   Output: index of the element in the array (4)\n2. Input: arr = [2, 1], key = 2\n   Output: index of the element in the array (0)\n3. Input: arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], key = 7\n   Output: index of the element in the array (3)\nConstraints:\n- The input array is rotated sorted.\n- The array contains at least two elements.\n- All elements in the array are distinct.\n```"
  },
  {
    "agent": "Senior Python Engineer",
    "task_name": "You are given a coding problem. Write a clean, executable Python file.",
    "full_prompt": "\n        You are given a coding problem. Write a clean, executable Python file.\n        \n        PROBLEM:\n        Use the clean Problem Statement provided by the Problem Architect above.\n        \n        REQUIREMENTS:\n        1. Define a class named `Solution`.\n        2. Implement a method `solve`.\n        3. Provide an Optimized (O(n) or O(log n)) approach.\n        \n        STRICT OUTPUT RULES (VIOLATION = FAIL):\n        1. NO PREAMBLE. Do not say \"Here is the code\".\n        2. NO POSTSCRIPT. Do not explain the code.\n        3. NO MARKDOWN TICKS. Do not use ```python or ```.\n        4. START DIRECTLY with \"class Solution\".\n        5. OUTPUT ONLY VALID PYTHON CODE.\n        ",
    "response": "class Solution:\n    def solve(self, arr, key):\n        left, right = 0, len(arr) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if arr[mid] == key:\n                return mid\n            \n            # If the array is rotated and the left half is sorted\n            if arr[left] <= arr[mid]:\n                if arr[left] <= key < arr[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If the right half is sorted\n            else:\n                if arr[mid] < key <= arr[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"
  },
  {
    "agent": "CS Professor",
    "task_name": "Analyze the following Python solution and explain it to a student.",
    "full_prompt": "\n        Analyze the following Python solution and explain it to a student.\n        \n        CODE TO ANALYZE:\n        Analyze the Python code provided by the Senior Python Engineer above.\n        \n        OUTPUT REQUIREMENTS:\n        \n        1. **Time Complexity Analysis**: \n           - State the Big O (e.g., O(N)).\n           - CRITICAL: Explicitly explain that the loop runs N times and the dictionary lookup `if x in dict` takes O(1) time on average.\n           - Therefore, N * O(1) = O(N).\n           \n        2. **Space Complexity Analysis**: \n           - State the Big O.\n           - Explain that we use a dictionary/hash map to store at most N elements.\n           \n        3. **Step-by-Step Reconstruction Logic**:\n           - Explain the logic in such detail that a developer could rewrite the code just by reading these steps.\n           - Mention exactly what variables are initialized.\n           - Describe the condition for the loop.\n           - Describe the specific math (`target - current_num`) used to find the complement.\n           - Explain the `if/else` logic: What happens if the complement IS found? What happens if it IS NOT found?\n           - Mention the final return statement if no pair is found.\n        \n        STRICT FORMAT:\n        - Do NOT output the code block again.\n        - Use Markdown headers (##).\n        - Use bullet points for the steps.\n        ",
    "response": "```\n## Time Complexity Analysis\nThe time complexity of this solution is O(N), where N is the number of elements in the array.\n\n## Space Complexity Analysis\nThe space complexity of this solution is O(N), where N is the number of elements in the array.\n\n## Step-by-Step Reconstruction Logic\n\n### Initialize Variables\n* `left` and `right` variables are initialized to 0 and `len(arr) - 1`, respectively.\n* The initial range of possible indices for the key is `[0, len(arr) - 1]`.\n\n### Loop Condition\n* The loop continues until `left <= right`.\n\n### Inside the Loop\n* Calculate the midpoint `mid` using the formula `(left + right) // 2`.\n* Compare the value at the midpoint index with the key.\n* If the array is rotated and the left half is sorted, check if the key is within the range `[arr[left], arr[mid]]`. If it is, move the `right` pointer to `mid - 1`. Otherwise, move the `left` pointer to `mid + 1`.\n* If the right half is sorted, check if the key is within the range `[arr[mid], arr[right]]`. If it is, move the `left` pointer to `mid + 1`. Otherwise, move the `right` pointer to `mid - 1`.\n\n### Return Statement\n* If the loop ends and the key is found, return the index of the key.\n* If the loop ends and the key is not found, return `-1`.\n```"
  }
]