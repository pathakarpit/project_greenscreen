TITLE: Kosaraju's Theorem
DIFFICULTY: Medium
LINK: https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1
----------------------------------------

--- PROBLEM STATEMENT ---
```
Title: Kosaraju's Theorem
Description:
Given a graph G = (V,E), find all articulation points in the graph.
An articulation point is a vertex that, when removed, increases the number of connected components.

Examples:
Input 1:
- Graph G = ({A,B,C,D}, {(A,B),(B,C),(C,D)})
Output 1:
- Articulation points: B

Input 2:
- Graph G = ({A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}, 
    {(A,B), (B,C), (C,D), (D,E), (E,F), (F,G), (G,H), (H,I), (I,J),
     (J,K), (K,L), (L,M), (M,N), (N,O), (O,P), (P,Q), (Q,R), (R,S),
     (S,T), (T,U), (U,V), (V,W), (W,X), (X,Y), (Y,Z)})
Output 2:
- Articulation points: M, N

Input 3:
- Graph G = ({A,B,C,D,E}, {(A,B),(B,C),(C,D),(D,E)})
Output 3:
- No articulation points

Constraints:
1. Number of vertices (N) is between 1 and 10^5.
2. Each edge has a weight, but it's not used in the algorithm.

Note: I invented reasonable constraints as there was no information about them.
```

----------------------------------------

--- PROFESSOR'S EXPLANATION ---
This Python code defines a class called `Solution` with two methods: `dfs` and `solve`. The class uses depth-first search (DFS) to find all strongly connected components in an input graph. 

The algorithm initializes various data structures such as `graph`, `stack`, `visited`, `low`, `ids`, `id`, and `scc_count` based on the input graph.

The `dfs` method takes a vertex `at` as input, marks it as visited, assigns an id to it, recursively calls itself for all unvisited adjacent vertices, and updates the `low` dictionary accordingly. 

If a vertex has finished being visited (i.e., `low[at] == ids[at]`), it pops all vertices from the stack that are not `at`, removes them from the `visited` set, and increments the `scc_count`.

The `solve` method iterates over all vertices in the graph, calling the `dfs` method on unvisited vertices. 

After visiting all vertices, the algorithm returns a list of indices corresponding to strongly connected components (i.e., vertices whose id is not present in the `ids` dictionary).

This code uses a time complexity of O(N), where N is the number of vertices in the graph. The space complexity is also O(N) as we use dictionaries and stacks to store at most N elements.
