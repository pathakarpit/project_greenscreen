DSA PROBLEM: Event Photo Timeline Compression

PROBLEM STATEMENT
You are building backend logic for an event-based photo-sharing platform.
Each event contains multiple photos, and each photo has a timestamp in seconds.

To optimize storage and timeline viewing, photos taken close together should be grouped into clusters.

OBJECTIVE
Given a sorted list of photo timestamps, group them into clusters such that:

The difference between consecutive timestamps in a cluster is less than or equal to K seconds

Each photo belongs to exactly one cluster

The original chronological order is preserved

INPUT FORMAT

An integer array timestamps[] of size N
timestamps[i] represents the time (in seconds) when the i-th photo was taken
The array is sorted in ascending order

An integer K representing the maximum allowed gap (in seconds)

OUTPUT FORMAT

A list of clusters, where each cluster is a list of timestamps

CONSTRAINTS

1 ≤ N ≤ 100000

0 ≤ timestamps[i] ≤ 10^9

0 ≤ K ≤ 10^9

timestamps[] is sorted

EXAMPLE 1
Input
timestamps = [10, 15, 18, 40, 42, 90]
K = 5

Output
[
[10, 15, 18],
[40, 42],
[90]
]

Explanation
15 - 10 = 5 (same cluster)
18 - 15 = 3 (same cluster)
40 - 18 = 22 (new cluster)
42 - 40 = 2 (same cluster)
90 - 42 = 48 (new cluster)

EXAMPLE 2
Input
timestamps = [1, 2, 3, 4, 5]
K = 0

Output
[
[1],
[2],
[3],
[4],
[5]
]

EXAMPLE 3
Input
timestamps = [100, 105, 110, 115]
K = 10

Output
[
[100, 105, 110, 115]
]

EXPECTED TIME COMPLEXITY
O(N)

EXPECTED SPACE COMPLEXITY
O(N)

FOLLOW-UP QUESTIONS

How would you handle the problem if timestamps were not sorted?

Can this be solved using a two-pointer approach?

How would you enforce a minimum cluster size M?

How would you design this if timestamps arrive as a stream?

TOPICS COVERED
Arrays
Greedy Strategy
Sliding Window / Two Pointers
Backend System Modeling